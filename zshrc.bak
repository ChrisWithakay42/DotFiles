# ~/.zshrc

export ZSH="$HOME/.oh-my-zsh"

# Manually source plugins from their standard Oh My Zsh custom locations.
# The order here is important. Syntax highlighting should come first.
if [ -f "$ZSH/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ]; then
  source "$ZSH/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
fi
if [ -f "$ZSH/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh" ]; then
  source "$ZSH/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh"
fi

# --- Original Oh My Zsh Config ---
ZSH_THEME="powerlevel10k/powerlevel10k"

# Oh My Zsh plugins array now only contains built-in plugins and fzf.
# The two custom plugins above have been removed from this list as they are already loaded.
plugins=(
  git
  z
  docker
  docker-compose
  kubectl
  fzf
  vi-mode
)

# Source Oh My Zsh (this will also run compinit)
source $ZSH/oh-my-zsh.sh

# --- THE REST OF YOUR FILE IS UNCHANGED ---

# Powerlevel10k Instant Prompt
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Source Powerlevel10k theme config
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh



# --- Virtualenvwrapper ---
if [ -x /opt/homebrew/bin/python3 ]; then
  export VIRTUALENVWRAPPER_PYTHON=/opt/homebrew/bin/python3
elif command -v python3 &>/dev/null; then
  # Fallback if the specific Homebrew path isn't there but python3 is in PATH
  export VIRTUALENVWRAPPER_PYTHON=$(which python3)
else
  echo "WARNING: python3 from Homebrew or PATH not found. virtualenvwrapper might not work correctly."
fi

# Source virtualenvwrapper.sh
# For M1 Mac with Homebrew Python, pip installs scripts like virtualenvwrapper.sh to /opt/homebrew/bin
VIRTUALENVWRAPPER_SCRIPT_PATH="/opt/homebrew/bin/virtualenvwrapper.sh"

if [ -f "$VIRTUALENVWRAPPER_SCRIPT_PATH" ]; then
  source "$VIRTUALENVWRAPPER_SCRIPT_PATH"
elif [ -f "$HOME/.local/bin/virtualenvwrapper.sh" ]; then # Fallback for pip install --user
  source "$HOME/.local/bin/virtualenvwrapper.sh"
elif command -v virtualenvwrapper.sh &>/dev/null; then # Fallback if it's in PATH some other way
  source "$(which virtualenvwrapper.sh)"
else
  echo "WARNING: virtualenvwrapper.sh not found. Expected at $VIRTUALENVWRAPPER_SCRIPT_PATH or similar."
  echo "Please check your virtualenvwrapper installation."
fi

# --- Lazy Loading & Tool Initializations ---

# Pyenv Initialization
if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init -)"
fi

# NVM (Node Version Manager) Lazy Loading
if [ -s "$NVM_DIR/nvm.sh" ]; then
  load_nvm() {
    unset -f nvm node npm yarn pnpm npx
    \. "$NVM_DIR/nvm.sh" --no-use
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    "$@"
  }
  nvm() { load_nvm nvm "$@"; }
  node() { load_nvm node "$@"; }
  npm() { load_nvm npm "$@"; }
  yarn() { load_nvm yarn "$@"; }
  pnpm() { load_nvm pnpm "$@"; }
  npx() { load_nvm npx "$@"; }
fi

# SDKMAN Lazy Loading
if [ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ]; then
  load_sdkman() {
    unset -f sdk java
    source "$SDKMAN_DIR/bin/sdkman-init.sh"
    "$@"
  }
  sdk() { load_sdkman sdk "$@"; }
fi

# FZF (already good)
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# --- Your Aliases ---
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias lst="exa --icons -T -L 2"
alias ls="exa --icons"
alias ll="exa -l --icons"
alias la="exa -la --icons"
alias l.="exa -a | egrep '^\.'"
alias duh="du -sh * | sort -h"
alias cat="bat --style=plain"
alias vim="nvim"
alias v="nvim"
alias vi="nvim"
alias code="/Applications/vscode.app/Contents/Resources/app/bin/code"
alias flushdns="sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder"
alias update="brew update && brew upgrade && brew cleanup -s && brew doctor && pnpm update -g && omz update"
alias ip="curl ifconfig.me"
alias weather="curl wttr.in/london"
alias k="kubectl"
alias kgp="kubectl get pods"
alias kgs="kubectl get services"
alias kgd="kubectl get deployments"
alias kgn="kubectl get nodes"
alias kgns="kubectl get namespaces"
alias kdesc="kubectl describe"
alias klogs="kubectl logs"
alias kexec="kubectl exec -it"
alias kaf="kubectl apply -f"
alias kdf="kubectl delete -f"
alias kcuc="kubectl config use-context"
alias kcgc="kubectl config get-contexts"
alias kca="kubectl apply -f ."
alias kgpa="kubectl get pods --all-namespaces"
alias kga="kubectl get all"
alias kgan="kubectl get all --all-namespaces"
alias ksys="kubectl --namespace=kube-system"
alias kpf="kubectl port-forward"
alias dc="docker-compose"
alias dcu="docker-compose up -d"
alias dcd="docker-compose down"
alias dcr="docker-compose restart"
alias dcl="docker-compose logs -f"
alias dcb="docker-compose build"
alias dcp="docker-compose ps"
alias dce="docker-compose exec"
alias ds="docker system prune -af --volumes"
alias sshconfig="nvim ~/.ssh/config"
alias zshconfig="nvim ~/.zshrc"
alias gitconfig="nvim ~/.gitconfig"
alias nvimconfig="nvim ~/.config/nvim/init.lua"
alias tmuxconfig="nvim ~/.tmux.conf"
alias alacrittyconfig="nvim ~/.config/alacritty/alacritty.toml"
alias p10kconfig="p10k configure"
alias ohmyzsh="cd ~/.oh-my-zsh"
alias gadm="$HOME/Tools/gam7/gam"
alias tt="taskwarrior-tui"

# --- Your Functions ---
mcd() {
  mkdir -p "$1" && cd "$1" || return
}
extract() {
  for archive in "$@"; do
    if [ -f "$archive" ]; then
      case "$archive" in
      *.tar.bz2) tar xvjf "$archive" ;;
      *.tar.gz) tar xvzf "$archive" ;;
      *.bz2) bunzip2 "$archive" ;;
      *.rar) unrar x "$archive" ;;
      *.gz) gunzip "$archive" ;;
      *.tar) tar xvf "$archive" ;;
      *.tbz2) tar xvjf "$archive" ;;
      *.tgz) tar xvzf "$archive" ;;
      *.zip) unzip "$archive" ;;
      *.Z) uncompress "$archive" ;;
      *.7z) 7z x "$archive" ;;
      *) echo "don't know how to extract '$archive'..." ;;
      esac
    else
      echo "'$archive' is not a valid file"
    fi
  done
}
bak() {
  cp "$1" "$1"_$(date +%Y%m%d%H%M%S).bak
}


# --- Fabric YT Function ---
yt() {
    if [ "$#" -eq 0 ] || [ "$#" -gt 2 ]; then
        echo "Usage: yt [-t | --timestamps] youtube-link"
        echo "Use the '-t' flag to get the transcript with timestamps."
        return 1
    fi

    transcript_flag="--transcript"
    if [ "$1" = "-t" ] || [ "$1" = "--timestamps" ]; then
        transcript_flag="--transcript-with-timestamps"
        shift
    fi
    local video_link="$1"
    fabric -y "$video_link" $transcript_flag
}

_fabric_pattern_lazy_loader() {
  local pattern_name="$1"
  local pattern_path="$HOME/.config/fabric/patterns/$pattern_name"

  # Check if a file OR a directory with the typed command name exists.
  if [ -f "$pattern_path" ] || [ -d "$pattern_path" ]; then
    # 1. Create the alias for all subsequent calls. This is for future performance.
    alias "$pattern_name"="fabric --pattern $pattern_name"

    # 2. For THIS run, execute the intended `fabric` command directly.
    #    This completely avoids the recursive loop.
    shift # Removes the pattern name ($1) from the arguments list.
          # Now "$@" contains only the arguments that followed the pattern name.
    fabric --pattern "$pattern_name" "$@"
    return 0 # SUCCESS
  fi

  return 1 # FAILURE: This pattern was not found.
}

# The main Zsh handler. It is defined SECOND.
command_not_found_handler() {
  # Try to handle the command with our custom fabric loader.
  # The 'if' statement automatically checks the return code of the function.
  if _fabric_pattern_lazy_loader "$@"; then
    return 0
  else
    # Fall back to the standard Zsh "command not found" error.
    printf "zsh: command not found: %s\n" "$1" >&2
    return 127
  fi
}
# for pattern_file in $HOME/.config/fabric/patterns/*; do
#     # Get the base name of the file (i.e., remove the directory path)
#     pattern_name=$(basename "$pattern_file")
#
#     # Create an alias in the form: alias pattern_name="fabric --pattern pattern_name"
#     alias_command="alias $pattern_name='fabric --pattern $pattern_name'"
#
#     # Evaluate the alias command to add it to the current shell
#     eval "$alias_command"
# done
